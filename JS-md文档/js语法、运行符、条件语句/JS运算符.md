## 运算符
- 只要是运算符就应该有返回值。
- ECMA操作符具有很强大的功能，如算术运算符（加号和减号）、位操作符、关系操作符、相等操作符。
  它们可以适用于很多值，如字符串、数值、布尔值、对象。
- 注意：相应的操作符会自动调用的对象valueOf和toString方法，以便取得可以操作的值。
### 比较运算符
\>  <  >=  <=  ==  
- 注意：
1. 如果条件里面用=,因为= 是赋值操作，如果所赋值为0和false时，判断结果为false，如a=false；a = 0;其它情况都为true。
2. 使用相等运算符时，如果一个空变量var mm=""和值为false的变量相比，结果让人模糊。此时的mm类型是字符串。
  但是，返回的还是真值，因为JS里面相等运算符会认为空变量与false具有相同的含义。
  如果：var mm ；没有赋值，此时mm的类型是未定义（undefiend），此时再与false相比，返回的是false。
  如果要进行严格比较就要使用全等运算符===,此运算符不仅会比较值还会比较类型。
  同样：不等于操作符，也不严格，如果想严格比较不相等，就要使用 !==。
3. 如果是字符则按照ascii，进行比较。
4. NaN与任何数进行比较都是false。
#### 比较原则
比较原则如下：
1. 两个操作数都是数值，则进行数值比较。
2. 两个操作数都是字符串，则进行字符串ascii比较。
3. 一个操作数是数值，另一个操作数转换为数值，然后进行数值比较。
4. 如果一个操作数是对象，则调用这个对象valueO方法，如果没有就调用toString方法，在按照上面的规则比较。
5. 如果一个操作数是布尔值，则转换成数值，在进行比较。
- 注意：在比较字符串是，是把字符串中每个字符进行比较。
- 技巧：
1. 如果是英文字符串进行比较，则需要注意大小写。
2. 如果是数字字符比较，则比较每个字符的ASCII。
  "23" < "3" 是正确的。因为2的ascii字符编码50，而3的ascii字符编码是51.
### 相等 不等 全等 全不等 
!= === !==
- 相等和不等 先转换再比较。
- 全等和全不等 仅比较不转换
#### 比较原则
1. 如果一个操作数是布尔值，则先将其转换成数值（true 1 false 0），在比较。
2. 如果一个操作数是字符，一个是数值，先将字符转换成数值再进行比较。
3. null和undefined是相等的。
4. 如果一个操作数是NaN,那么相等运算结果false，不等结果是true，注意：NaN不等于NaN，NaN不等于任何数。
5. 如果两个操作数是对象，则比较这两个操作数是否为同一个对象（地址是否相同）。
### 算术运算符
- 算术运算符的对象，可以是数字、变量。
- 自增运算符、自减运算符。+ - * /   取余（模）%
- 其中：乘除法、取余运算优先级较高。
- 其中；+，可以用做字符串的拼接。
- 变量也可以完成拼接，var mood = "happy"; var message ="i am feeling" +mood;
- 甚至可以：把数值和字符串拼接在一起，因为JS是弱语言，数值自动转为字符串。
- 注意：如果把字符串拼接数值时，会出现以下情况。
  alert（"10"+20）  结果1020
  alert（10+20）		结果30
- +=（加法赋值或拼接运算）
- undefined + 数值 = NaN
#### 前置运算符
- 执行前置递增、递减操作符时，变量的值都是在语句被求值以前改变的,(通常被称为负效应)。
~~~
例如：
 var a = 29;
 var ss = ++a + 1;
 console.log(a);  //30
console.log(ss);  //31
~~~
##### 自增、自减运算符的规则
自增、自减运算符遵循以下规则：
1. 在用于包含有效的数字字符字符串时，先将其转化成数字值，再执行加1减1的操作，字符串变量变成数字值变量。
~~~
var ss = '123';
ss++;
console.log(typeof ss); //改变了变量类型
~~~
2. 在用于布尔值（true、false）时，先将true转化成 0,false转换成1，然后再执行加1减1的操作，布尔值变量变成数字变量。
3. 在用于浮点数时，直接执行加1减1的操作
4. 在用于对象时，先获取对象的valueOf（)方法取得一个可供操作的值，然后再按照上面的规则。如果结果是NaN,则再调用toString方法，在进行上面的操作，对象变量变成数值变量。
~~~
var ss = {
  age: 18,
  valueOf: function() {
    return -1;
  } 
}
console.log(ss++);
~~~
#### 常用组合
- 一元操作符如（=）与加号 + 的组合，
- 一元操作符如（=）与减号 - 的组合
  该组合对于非数值时，该操作符会像Number（）转型函数一样对这个值执行转换。
  对于布尔值 （1，0）
  对于非数值字符串，返回NaN
  对于 对象，先使用valueof 或 toString ，再转换得到的值。
##### = +
1. = +
- 数值类型，= +没有效果
~~~
var num = 2;
var num1 = + 2;
console.log(num);  //2
console.log(num1);  //2
~~~
- 非数值类型，+号会将数据类型转换。
  例如：
~~~
var  a1 = '01';
var a2 = '1.1';
var s = 'z';
var b = false;
var f = 1.1;
var obj = {
  valueOf: function() {
    return -1;
  }
}
a1 = +a1;  //数值变量1
a2 = +a2;   //数值变量1.1
s = +s;     //NaN
b = +b;     //数值变量 0
f = +f;     //数值变量 1.1，不变
obj = +obj; //数值对象 变成 数值变量-1
~~~
##### = -
- = - 操作符，在用于数值时会将其变成负值，如果用于非数值和 = + 一样，只不过得到的数值都是负的。
#### ＋号拼接字符注意事项
~~~
var ss = 10;
var mm = 20;
var cc = "和是"+ ss + mm;
console.log(cc);　　　//和是1020
~~~
- 出现这种结果的原因是：加法运算符是独立执行的，从左到右依次执行，先是"和是ss"(和是10)，然后再加上mm（和是1020）。
##### 解决方法：
var ss = 10;
var mm = 20;
var cc = "和是"+ (ss + mm);
console.log(cc);　　//和是30
- 利用运算符优先级。
### 逻辑操作符
与：&&、或：||、非！（）：
#### 逻辑与注意事项
逻辑与可以应用任何类型的操作数，而不仅仅布尔值。
在有一个操作数不是布尔值的的情况下，逻辑与就不一定返回布尔值。遵循以下规则：
1. 如果第一个操作数是对象，则返回第二个操作数。
2. 如果第二个操作数是对象，只有在第一个操作数的求值结果为true的情况下，才返回该对象。
3. 如果两个操作数都是对象，则返回第二个操作数。
4. 如果有一个操作数为ＮａＮ，则返回ＮａＮ。
5. 如果有一个操作数为ｎｕｌｌ，则返回ｎｕｌｌ。
6. 如果有一个操作数属于ｕｎｄｅｆｉｎｅｄ，则返回ｕｎｄｅｆｉｎｅｄ．
  注意：逻辑与操作符属于短路操作，如果第一个操作数能绝对返回结果就不对第二个操作数求值。
  如果第一个数为ｆａｌｓｅ，则无论第二个操作数是什么值，返回结果都不可能是ｔｒｕｅ。
- 例子
~~~
var founnd = true;
console.log(founnd && age);  
//会产生错误，因为第一个操作数是true，所以继续第二个操作数求值，第二个未定义未声明
------------------
var lll = false;
console.log(lll && hhh); 
//返回false，因为第一个操作数为false，所以不管第二个操作数的值是什么，都返回false
~~~
#### 逻辑或注意事项
- 逻辑或 与 逻辑与相似，在有一个操作数不是布尔值的的情况下，逻辑与就不一定返回布尔值。遵循以下规则：
1. 如果第一个操作数是对象，则返回第一个操作数。
2. 如果第一个操作数求值结果是ｆａｌｓｅ，则返回第二个操作数。
3. 如果两个操作数都是对象，则返回第一个操作数。
4. 如果有两个操作数为ＮａＮ，则返回ＮａＮ。
5. 如果有两个操作数为ｎｕｌｌ，则返回ｎｕｌｌ。
6. 如果有两个操作数属于ｕｎｄｅｆｉｎｅｄ，则返回ｕｎｄｅｆｉｎｅｄ．
- 注意：逻辑或操作符也是短路操作符。也就是说第一个操作数的求值结果为ｔｒｕｅ，则就不会对第二个操作数求值了。
- 例子
~~~
var founnd = true;
console.log(founnd || age);  
//返回true，因为第一个操作数为true，所以不管第二个操作数的值是什么，都返回true

var ｓ = false;
console.log(s || hhh); 
//会产生错误，因为第一个操作数是fasle，所以继续第二个操作数求值，第二个未定义未声明
~~~
#### 运算符的优先级
1. ()  优先级最高 
2. 一元运算符  ++   --   !
3. 算数运算符  先*  /  %   后 +   -
4. 关系运算符  >   >=   <   <=
5. 相等运算符   ==   !=    ===    !==
6. 逻辑运算符 先&&   后||
7. 赋值运算符  =

- 规律：
  先一元   后  二元 
  先 算数  后 关系
  先相等 后逻辑
  最后赋值
#### 三元运算符
- 三元运算符 ？
- 表达式1 ? 表达式2 : 表达式3
  如果表达式1为true ，则整个表达式的结果就是表达式2的值，如果表达式false，则整个表达式的结果就是表达式3的值.
### 位操作符
- 位操作符用于在最基本的层次，即按内存中表示数值的位来操作数值。
- ECMAscript中所有的数值，都以IEEE~756 64位的格式存储。但位操作符并不直接操作64位的值。而是先将64位转换成32位，然后操作，再返回64位。
- 对于有符号的整数，（0~31）32位中的前31位用于表示整数的值，第32位用来存储符号（0代表正，1代表负）。
  如：数值的18的二进制
  0000000000000000000000000010010.
  有效位10010，第32为代表符号。

- 对于负数;采用二进制的补码格式保存。
  如-18的二进制。
  1.反码：111111111111111111111101101
  2.补码：111111111111111111111101110

- 注意：对于有符号整数时，是不能访问第32位的。
  ECMAscript 会隐藏这些信息。如：
  var ss = -18;
  console.log(ss.toString(2));   //-10010
- 无符号数值范围比有符号数值范围要大。2的32次方。
####注意事项
1. 位操作符，会产生副作用对特殊值NaN和Infinity应用位操作符时，会当作0处理。
2. 如果对非数值应用位操作符，会先使用Number（）函数将该值转换成数值（自动完成），然后再应用位操作符，得到的是一个数值。
#### 按位与 &
按位与操作符由一个和字符号 & 表示。按位与就是将两个数值的每一位对齐。
例如：
var ss = 25 & 3;
console.log(ss);    //1
具体过程如下：
00000000000000000000000000011001
AND
00000000000000000000000000000011
结果：
00000000000000000000000000000001
#### 按位非~
按位非 由一个波浪线 ~ 表示 ，就是按位取反。按位非操作符是ECMAScript操作符中少数几个与二进制有关的。
例如：
var ss = 25;   //二进制00000000000000000000000000011001
var mm = ~ss;  //二进制11111111111111111111111111100110
console.log(mm);  //-26
- 按位取反的本质：操作数的负值减1
- 下面的代码也能有同样的效果，但是由于位操作符是底层的，速度较快。
  var ss = 25;
  var mm = -ss -1;
  console.log(mm);  //-26
#### 按位或 |
按位或OR操作符由一个竖线字符号 | 表示,同时也有两个操作数。
例如：
var ss = 25 | 3;
console.log(ss);  //27
具体过程如下：
00000000000000000000000000011001
OR
00000000000000000000000000000011
结果：
00000000000000000000000000011011
#### 按位异或^
按位异或XOR，按位异或操作符由一个插入符号 ^ 表示。
按位异或的本质：相同为0,不同为1.
例如：
var ss = 25 ^ 3;
console.log(ss);   //26
具体过程如下：
00000000000000000000000000011001
XOR
00000000000000000000000000000011
结果：
00000000000000000000000000011010
#### 左移<<
- 左移操作符由  << 表示，这个操作符可以让数值的所有位向左移动指定的位数。
- 例如：数值2 （二进制10），向左移动5位，结果就是64（1000000）.
  var oldValue = 2;
  var newOldValue = 2 << 5;
  console.log(newOldValue);
- 注意：
1. 左移操作符会给数值右侧的多出的位用0填充。
2. 左移不会影响操作数的符号位。
#### 右移
##### 有符号的右移>>
- 有符号的右移有操作符 >> 表示。这个操作符会将数值向右移动，但保留符号位（正、负号）。
- 注意：
  在移位过程中，原数值也会出现空位。只不过这次的空位出现在原数值的左侧，符号位的右侧（紧贴着），然后ECMA会用符号位的值填充所有空位。
  var oldValue = 64;
  var newOldValue = oldValue >> 5;
  console.log(newOldValue);
##### 无符号的右移>>>
无符号的右移操作符由 >>> 表示。这个操作符将数值的所有32位全部右移。对于正数来说其结果与有符号右移相同。
注意：一旦负数使用该该操作符就会发生错误。
var oldValue = -64;
var newOldValue = oldValue >>> 5;
console.log(newOldValue);
具体过程：首先-64的二进制码：
11111111111111111111111111000000.
然后无符号右移操作符 >>> 5   将其转换为
00000111111111111111111111111110
该二进制码的十进制表示 134217726
### 逗号操作符
1. 逗号操作符不仅可以用于声明多个变量。
2. 还可以用于赋值，在用于赋值时，逗号操作符总会返回表达式中的最后一项。
  var ss = (1,2,3,4,0);
  console.log(ss);  //0