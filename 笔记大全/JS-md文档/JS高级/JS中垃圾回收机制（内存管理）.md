# JS垃圾回收机制
## 概述
- JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。
- C#、Java、JavaScript有自动垃圾回收机制，但c++和c就没有垃圾回收机制，也许是因为垃圾回收机制必须由一种平台来实现。在JS中，JS的执行环境会负责管理代码执行过程中使用的内存。
## 变量的生命周期
- 当一个变量的生命周期结束之后它所指向的内存就应该被释放。JS有两种变量，全局变量和在函数中产生的局部变量。局部变量的生命周期在函数执行过后就结束了，此时便可将它引用的内存释放（即垃圾回收），但全局变量生命周期会持续到浏览器关闭页面。
## 内存管理
- 不管是高级语言，还是低级语言。内存的管理都是：
1. 分配内存
2. 使用内存（读或写）
3. 释放内存
- 前两步，大家都没有太大异议。关键是释放内存这一步，各种语言都有自己的垃圾回收（garbage collection, 简称GC）机制。做GC的第一步是判断堆中存的是数据还是指针，是指针的话，说明它被指向活跃的对象。有3种判断方法：
1. Conservative：如果存储格式是地址，就认为是。C/C++有用到这种算法。
2. Compiler hints：对于静态语言，比如Java，编译器是知道它是不是指针的，所以可以用这种。
3. Tagged pointers：JavaScript用的是这种，在字末位进行标识，1为指针。
- 对于JavaScript而言，最初的垃圾回收机制，是基于引用计次来做的。后来升级为标记清除。
### 引用计次
- 当对象被引用次数为0时，就被回收。潜在的一个问题是：循环引用时，两个对象都至少被引用了一次，将不能自动被回收。所以导致，我们常讲的内存泄露。
~~~
// 引用计次
var a = {t: 1}; // 对象 `{t: 1}` （以下简称obj）被引用一次
var b = a; // obj 被引用两次
a = null; // obj 现在为1次
b = null; // obj 现在为0次，可回收

// 循环引用
function fn() {
    var a = {};
    var b = {};
    a.b = b;
    b.a = a;
}

fn();
~~~
### 标记清除
- 这是当前主流的GC算法，V8里面就是用这种。当对象，无法从根对象沿着引用遍历到，即不可达（unreachable），进行清除。对于上面的例子，fn() 里面的 a 和 b 在函数执行完毕后，就不能通过外面的上下文进行访问了，所以就可以清除了。
#### V8的GC机制
- 在大部分的应用场景：一个新创建的对象，生命周期通常很短。所以，V8里面，GC处理分为两大类：新生代和老生代。
#####  新生代
- 新生代的堆空间为1M~8M，而且被平分成两份（to-space和from-space），通常一个新创建的对象，内存被分配在新生代。当to-space满的时候，to-space和form-space交换位置（此时，to空，from满），并执行GC.如果一个对象被断定为，未被引用，就清除；有被引用，逃逸次数+1（如果此时逃逸次数为2，就移入老生代，否则移入to-space）。
##### 老生代
- 老生代的堆空间大，GC不适合像新生代那样，用平分成两个space这种空间换时间的方式。老生代的垃圾回收，分两个阶段：标记、清理（有Sweeping和Compacting这两种方式）。
###### 标记
- 标记，采用3色标记：黑、白、灰。步骤如下：
1. GC开始，所以对象标记为白色。
2. 根对象标记为黑色，并开始遍历其子节点（引用的对象）。
3. 当前被遍历的节点，标记为灰色，被放入一个叫 marking bitmap 的栈。在栈中，把当前被遍历的节点，标记为黑色，并出栈，同时，把它的子节点（如果有的话）标记为灰4色，并压入栈。（大对象比较特殊，这里不展开）
4. 当所有对象被遍历完后，就只剩下黑和白。通过Sweeping或Compacting的方式，清理掉白色，完成GC。
### JavaScript的根对象
- GC的时候，从根对象开始遍历。在浏览器，根对象是 window；在 Node.js 中，是 global（或称为root）.
~~~
//In Node.js
var a = 1;
b = 2;
console.log(root === global); //true
console.log(root.a, root.b); //undefined 2