项目描述：
1. 怎么接到工作，做一个什么样子的项目
2. 开发周期： 3 - 4 个月，  
   + 接到工作，开会讨论
   + UI设计 + 后台接口准备 + 数据库数据准备
   + 前端开发（前端工作大概在2-3周左右，剩余时间进行优化，bug修改，测试，调试）
   + 测试（各种测试）
   + 调试修改
   + 测试（各种测试）
   + 循环往复无限期
   + 项目部署
3. 构建项目使用 vue-cli + webpack，整栈使用单页面应用程序开发（全部组件化，模块化），采用es6官方模块化标准
4. 视图层主要使用 element-ui 完善视图
5. 在开发过程中，所有路由导航使用 vue-router，因为页面需要token令牌登入，所以使用了路由导航钩子处理token令牌的携带问题
6. 在开发过程中，所有请求都是用 axios 来完成，在使用过程中，为了方便开发，把 axios 挂载到了 Vue 的原型上，供所有 Vue 实例使用
7. 在商品分类组件中，使用table-tree组件，在element-ui中没有，单独使用element-table-tree插件完成

业务描述：

"#/user"
1. 使用 vue-router 进行前台路由导航
2. 当打开 users 组件的时候，在当前组件的生命周期钩子（created）中，使用 axios 进行后台数据请求
   + 在这里有做 请求拦截 和 响应拦截 来处理一些意外情况，或者不符合规则的操作
   + 使用 async 函数来处理请求，当请求数据回来以后，使用的 element-ui 中的 table 组件进行的页面渲染
   + 当组件完全渲染完成后，就可以正常显示所有数据了

"#/rights"
1. 使用 vue-router 进行前台路由导航
2. 当点击授权按钮的时候，通过 axios 进行所有权限的请求，用返回的数据，进行权限树的渲染
   + 通过 axios 进行当前行用户数据请求，根据当前用户已经拥有的权限进行权限树中对应选项的选中状态操作
3. 当修改过权限授权的状态以后，点击确定按钮决定权限修改
4. 点击确定按钮以后，根据选中状态的 id ，向后台发送所有权限 id值
5. 因为服务器的接口中描述是完全覆盖式替换，所以不需要考虑以前的权限问题，只发送最新所有权限的就好
6. 响应成功以后，重新加载当前最新的所用角色数据（达到实时跟新数据的需求）


困难：
1. 递归问题：
   + 在处理权限管理的时候，第一次完成是以循环嵌套循环的方式进行，后来因为业务需求的改变，层级关系进行改变，导致循环嵌套增加
   + 考虑到代码冗余问题，和有可能出现的下次修改和层级改变，改用递归方式实现
   + 在使用递归的时候，因为层级比较复杂，数据结构比较复杂，所以没有实现，在 google 查阅文档后，进行两次 demo 测试后改正
   + 最终使用递归方式完成

2. 伪造token问题：
   + 因为在测试的时候，有测试人员反映，存在token伪造问题，虽然进入页面后，没有数据渲染，但是用户体验并不好
   + 考虑使用 axios 中的响应拦截器解决问题，因为伪造的 token 虽然没有正确性，但是依然会发出请求，只不过所有的无效token都会返回 403响应状态码
   + 就使用了 axios 中的响应拦截器，在响应拦截器中进行响应的判断，只要响应状态吗为 403，那么就直接进行 登录页跳转

3. 分页问题
   + 在分页的过程中，依旧使用 element-ui 组件完成，但是有一个不好解决的问题出现，就是更换当前显示条数以后，跟换页面不进行数据更新
   + 一开始考虑，在两个change事件中互相调用解决问题，发现有效果，但是页码更新后有缺陷，需要多点击几次才会出现效果
   + 后来查阅文档，发现 .sync 修饰符可以解决一部分，就放弃了两个change事件互相调用，使用 .sync 修饰符解决
   + 发现依旧存在问题，还是不能完全解决，需要跟换页码后点击两次才会刷新的情况，
   + 经过仔细研究以后，发现：页码改变只会导致分页组件的 css 样式改变，但是真实的数据虽然会因为 .sync 修饰符而改变，但是change事件默认为没有发生改变，所以导致不会更新数据的问题
   + 这是 element-ui 组件的问题，考虑自己封装一个组件解决这个问题






移动端：
1. 怎么接到工作，工作需求
2. 因为当前项目开发的是一个大型电商项目，所以PC端和移动端是两套设计方案，所以在当前页面不需要适配PC端，只专注于移动端适配就可以
3. 所以使用的是 mui 进行视图效果渲染，一些动画效果使用的是 zepto
4. 与后台的数据交互，因为已经使用了 zepto，就直接使用 $.ajax 完成
5. 在页面渲染中，因为需要轮播图，考虑到 zepto 需要单独引入 animate 插件完成，所以这里直接使用了更为便捷高效的 swiper 插件完成轮播图
6. 使用了 iScroll 插件完成了浏览器滚动事件，实现了上拉加载，下拉刷新业务需求
7. 渲染数据的时候使用的 art-template 模板引擎进行数据渲染

困难：
1. 顶部固定和底部固定
   + 当以个通栏使用 position: fixed 以后，导致设置的 margin: 0 auto 不生效了，当屏幕变大以后，不在生效
   + 后来发现用户体验不好，考虑使用js强行定位，但是发现需要大量代码实现，效果并不好，在网速不好的情况下会有卡顿和延迟的现象出现，影响用户体验
   + 查阅文档和 demo 测试后，发现可以使用 css 的方式解决，在当前固定定位的容器外层在此包裹容器固定位置，内层容器进行定位就解决问题了
2. 使用rem进行布局的时候，发现随着视口的变小，导致文字内容随之变小，影响用户体验
   + 考虑到是文字像素的问题，使用 css 中@media进行媒体查询，随之改变根文字大小来实现，视口变小，文字放大的功能
   + 但是随之而来的是，需要调整的太多，使 css 变得非常复杂，不利于阅读和后期维护
   + 改用 js 判断屏幕尺寸，在整体页面加载的时候，最快时间内判断屏幕尺寸，根据屏幕尺寸决定跟文字大小，达到视口和文字平衡的状态
   + 但是，考虑到需要加载 js 以后才可以实现，没有 css 改变加载的块，又会有延迟的现象出现
   + 最后整合考虑，因为是在移动端，现在网速都比较好，并且使用 js 的方法更利于后期维护和代码可读性，最终考虑使用 js 方式解决问题
3. click和touch问题
   + 最开始整zhan都是使用 click 注册的点击事件，完成和用户的交互
   + 后来测试人员反馈有 300ms 左右的延迟出现，强行要求解决，为此进行过争吵，个人认为不会影响用户体验，但是在3G网络下测试，确实影响用户体验
   + 开始查询解决方案，发现可以使用移动端的 touch 事件可以来解决 click 的 300ms 延迟时间问题，但是需要自己封装没因为每一个点击事件都是需要 touchstart 和 touchend 联合使用
   + 最开始时候，自己进行封装使用，后来发现代码冗余过多，耦合过多，不利于维护和阅读，而且事件回调函数不是很齐全，还要单独封装
   + 在掘金中发现可以使用 touch 插件来解决所有问题


