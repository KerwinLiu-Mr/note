## B/S网络架构概述

- 我们先了解下B/S网络架构是什么？B/S网络架构从前端到后端都得到了简化，**都基于统一的应用层协议HTTP来交互数据，HTTP协议采用无状态的短链接的通信方式**，通常情况下，一次请求就完成了一次数据交互，通常也对应一个业务逻辑，然后这次通信连接就断开了。采用这种方式是为了能够同时服务更多的用户，**因为当前互联网应用每天都会处理上亿的用户请求，不可能每个用户访问一次后就一直保持住这个连接**。
- 当一个用户在浏览器里输入[www.google.com](https://link.jianshu.com?t=http://www.google.com)这个URL时，将会发生如下操作：

1. 首先，浏览器会请求**DNS把这个域名解析成对应的IP地址**；
2. 然后，根据这个IP地址在互联网上找到对应的服务器，**建立Socket连接，向这个服务器发起一个HTTP Get请求**，由这个服务器决定返回默认的数据资源给访问的用户；
3. 在服务器端实际上还有复杂的业务逻辑：**服务器可能有多台**，到底指定哪台服务器处理请求，这需要一个**负载均衡设备**来平均分配所有用户的请求；
4. 还有请求的数据是**存储在分布式缓存里还是一个静态文件中，或是在数据库里**；
5. 当数据返回浏览器时，浏览器解析数据发现还有**一些静态资源（如：css，js或者图片）时又会发起另外的HTTP请求**，而这些请求**可能会在CDN上**，那么CDN服务器又会处理这个用户的请求；

- **不管网络架构如何变化，但是始终有一些固定不变的原则需要遵守：**
  1. 互联网上所有**资源都要用一个URL来表示**。URL就是统一资源定位符；
  2. 必须**基于HTTP协议**与服务端交互；
  3. 数据**展示必须在浏览器中**进行；

## 浏览器缓存机制

- 当我们使用Ctrl+F5组合键刷新一个页面时，**首先是在浏览器端，会直接向目标URL发送请求，而不会使用浏览器缓存的数据；其次即使请求发送到服务端，也有可能访问到的是缓存的数据**。所以在HTTP的请求头中会增加一些请求头，它告诉服务端我们要获取最新的数据而非缓存。**最重要的是在请求Head中增加了两个请求项Pragma:no-cache和Cache-Control:no-cache**。

1. **Cache-Control/Pragma**

   - 这个HTTP Head字段**用于指定所有缓存机制在整个请求/响应链中必须服从的指令，如果知道该页面是否为缓存，不仅可以控制浏览器，还可以控制和HTTP协议相关的缓存或代理服务器**
   - **Cache-Control/Pragma字段的可选值：**

   ~~~
   Public       //所有内容都将被缓存，在响应头中设置
   Private      //内容只被缓存到私有缓存中，在响应头中设置
   no-cache     //所有内容都不会被缓存，在请求头和响应头中设置
   no-store     //所有内容都不会被缓存到缓存或Internet 临时文件中，在响应头中设置
   must-revalidation/proxy-revalidation  //如果缓存的内容失效，请求必须发送到服务器/代理以进行重新验证，在请求头中设置
   max-age=xxx   //缓存的内容将在xxx秒后失效。这个选项只在HTTP1.1中可用。在Last-Modified一起使用时优先级较高，在响应头中设置
   ~~~

   - Cache-Control请求字段被各个浏览器支持的较好，**而且它的优先级也比较高**，它和其他一些请求字段（如Expires）同时出现时，**Cache-Control会覆盖其他字段**
   - **Pragma字段的作用和Cache-Control有点类似**，它也是在HTTP头中包含一个特殊的指令，使相关的服务器来遵守，**最常用的就是Pragma:no-cache，它和Cache-Control:no-cache的作用是一样的**。

2. **Expires 缓存过期时间**

   **Expires通常的使用格式是Expires:Sat,25 Feb 2012 12:22:17 GMT**，后面跟着一个日期和时间，**超过这个值后，缓存的内容将失效**，也就是**浏览器在发出请求之前检查这个页面的这个字段，看该页面是否已经过期了，过期了将重新向服务器发起请求**。

3. **Last-Modified/Etag 最后修改时间**

   - **-Last-Modified字段一般用于表示一个服务器上的字段的最后修改时间**，资源可以是静态（静态内容自动加上Last-Modified）或者动态的内容（如Servlet提供了一个getLastModified方法用于检查某个动态内容是否已经更新），**通过这个最后修改时间可以判断当前请求的资源是否是最新的**。
   - 一般服务器端在响应头中返回一个Last-Modified字段，告诉浏览器这个页面的最后修改时间，如：Sat,25 Feb 2012 12:55:04 GMT，**浏览器再次请求时在请求头中增加一个If-Modified-Since:Sat,25 Feb 2012 12:55:04 GMT字段**，询问当前缓存的页面是否是最新的，**如果是最新的就会返回304状态码**，告诉浏览器是最新的，服务器也不会传输新的数据。
   - 与Last-Modified字段有类似功能的还有一个Etag字段，**这个字段的作用是让服务端给每个页面分配一个唯一编号，然后通过这个编号来区分当前这个页面是否是最新的**。这种方式比使用Last-Modified更加灵活，但是在后端的Web服务器有多台时比较难处理，**因为每个Web服务器都要记住网站的所有资源编号，否则浏览器返回这个编号就没有意义了**。

##  DNS域名解析

1. **浏览器缓存检查（本机）**

- **-浏览器会首先搜索浏览器自身的DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有www.google.com对应的条目，而且没有过期，如果有且没有过期则解析到此结束**。
- 浏览器缓存域名也是有限制的，不仅浏览器缓存大小有限制，而且缓存的时间也有限制，通常情况下为几分钟到几小时不等，**域名被缓存的时间限制可以通过TTL属性来设置**。这个缓存时间太长和太短都不好，如果缓存时间太长，一旦域名被解析到的IP有变化，会导致被客户端缓存的域名无法解析到变化后的IP地址，以致该域名不能正常解析，这段时间内有可能会有一部分用户无法访问网站。如果时间设置太短，会导致用户每次访问网站都要重新解析一次域名。
- 注：我们怎么查看Chrome自身的缓存？可以使用 [chrome://net-internals/#dns](https://link.jianshu.com/?t=chrome://net-internals/#dns) 来进行查看

2. **操作系统缓存检查（本机）+hosts解析（本机）**

- 如果浏览器自身的缓存里面没有找到对应的条目，**其实操作系统也会有一个域名解析的过程，那么Chrome会首先搜索操作系统自身的DNS缓存中是否有这个域名对应的DNS解析结果，如果找到且没有过期则停止搜索解析到此结束**。
- **其次在Linux中可以通过/etc/hosts文件来设置，你可以将任何域名解析到任何能够访问的IP地址**。如果你在这里指定了一个域名对应的IP地址，那么浏览器会首先使用这个IP地址。**当解析到这个配置文件中的某个域名时，操作系统会在缓存中缓存这个解析结果**，缓存的时间同样是受这个域名的失效时间和缓存的空间大小控制的。

3. **本地区域名服务器解析（LDNS）**

- 如果在hosts文件中也没有找到对应的条目，**浏览器就会发起一个DNS的系统调用，就会向本地配置的首选DNS服务器**（LDNS一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起域名解析请求（通过的是UDP协议向DNS的53端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址）。
- 在我们的网络配置中都会有“DNS服务器地址”这一项，**这个地址就用于解决前面所说的如果两个过程无法解析时要怎么办，操作系统会把这个域名发送给这里设置的LDNS，也就是本地区的域名服务器**。**这个DNS通常都提供给你本地互联网接入的一个DNS解析服务**，例如你是在学校接入互联网，那么你的DNS服务器肯定在你的学校，如果你是在一个小区接入互联网的，那这个DNS就是提供给你接入互联网的应用提供商，即电信或者联通，也就是通常所说的SPA，那么这个DNS通常也会在你所在城市的某个角落，通常不会很远。**这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素**。大约80%的域名解析都到这里就已经完成了，所以LDNS主要承担了域名的解析工作。
- **运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。**

4. **根域名服务器解析（Root Server）**
  如果LDNS没有找到对应的条目，**则由运营商的DNS代我们的浏览器发起迭代DNS解析请求**。它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），**找到根域的DNS地址，就会向其发起请求**（请问[www.google.com](https://link.jianshu.com?t=http://www.google.com)这个域名的IP地址是多少啊？）

5. **根域名服务器返回给本地域名服务器一个所查询域的主域名服务器(gTLD Server)地址**，gTLD是国际顶级域名服务器，如.com、.cn、.org等，全球只有13台左右。
   根域发现这是一个顶级域com域的一个域名，**于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址**，你去找它去。

6. **本地域名服务器(Local DNS Server)再向上一步返回的gTLD服务器发送请求**。
   于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问[www.google.com](https://link.jianshu.com?t=http://www.google.com)这个域名的IP地址是多少?），**com域这台服务器告诉运营商的DNS我不知道www.google.com这个域名的IP地址，但是我知道google.com这个域的DNS地址**，你去找它去。

7. **接受请求的gTLD服务器查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是你注册的域名服务器**，例如你在某个域名服务提供商申请的域名，那么这个域名解析任务就由这个域名提供商的服务器来完成。

   于是运营商的DNS又向google.com这个域名的DNS地址（**这个一般就是由域名注册商提供的，像万网，新网等**）发起请求（请问[www.google.com](https://link.jianshu.com?t=http://www.google.com)这个域名的IP地址是多少？），**这个时候google.com域的DNS服务器一查，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了www.google.com这个域名对应的IP地址**。

8. **Name Server域名服务器会查询存储的域名和IP的映射关系表**，正常情况下都根据域名得到目标IP记录，连同一个TTL值返回给DNS Server域名服务器。

9. **返回该域名对应的IP和TTL值**，Local DNS Server会缓存这个域名和IP的对应关系，缓存的时间由TTL值控制。

10. **把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束**。

  举个例子来说，你想知道某个一起上法律课的女孩的电话，并且你偷偷拍了她的照片，回到寝室告诉一个很仗义的哥们儿，这个哥们儿二话没说，拍着胸脯告诉你，甭急，我替你查(**此处完成了一次递归查询，即，问询者的角色更替**)。然后他拿着照片问了学院大四学长，学长告诉他，这姑娘是xx系的；然后这哥们儿马不停蹄又问了xx系的办公室主任助理同学，助理同学说是xx系yy班的，然后很仗义的哥们儿去xx系yy班的班长那里取到了该女孩儿电话。(**此处完成若干次迭代查询，即，问询者角色不变，但反复更替问询对象**)最后，他把号码交到了你手里。完成整个查询过程。
##  发起TCP的3次握手

- 拿到域名对应的IP地址之后，**User-Agent（一般是指浏览器）会以一个随机端口（1024 < 端口 < 65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。**这个连接请求（原始的http请求经过TCP/IP4层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。

1. **Client首先发送一个连接试探**，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复。
2. **Server监听到连接请求报文后，如同意建立连接，则向Client发送确认**。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。
3. **Client收到确认后还需再次发送确认，同时携带要发送给Server的数据**。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。

