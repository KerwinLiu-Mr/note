## 了解 - 浏览器端的 AMD 和 CMD 模块化规范

> 注意：浏览器端不能使用 CommonJS规范；因为 CommonJS 下，模块是同步加载的；

> AMD/CMD可以理解为是commonjs在浏览器端的解决方案，AMD/CMD下，模块都是异步加载的；

1. AMD模块化规范代表：RequireJS

   - 主要特性1：对于依赖的模块，AMD 是提前执行；
   - 主要特性2：推崇依赖前置；

2. CMD模块化规范代表：SeaJS

   - 主要特性1：对于依赖的模块，CMD 是延迟执行；CMD 推崇 as lazy as possible.
   - 主要特性2：推崇依赖就近；

3. ES6的模块化（**大趋势**）：es6是在**语言标准层面上**，实现了模块功能，而且实现得相当简单，**完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案**；

   比如:webpack打包工具，就是遵循ES6的模块化的模块化规范。


## 模块加载机制

### 优先从缓存中加载

- 当一个模块初次被 `require` 的时候，会执行模块中的代码，当第二次加载相同模块的时候，会优先从缓存中查找，看有没有这样的一个模块！
- 好处：提高模块的加载速度；不需要每次都重新执行并加载模块！

### 核心模块的加载机制

- 先查找缓存；如果缓存中没有，再去加载核心模块；

### 用户模块的加载机制

- 先查找缓存；

- 如果缓存中没有则尝试加载用户模块；

- 如果在加载用户模块时候省略了后缀名，则：

  ```
  首先，严格按照指定的名称去查找
  其次，尝试加载后缀名是 .js 的文件
  如果没有.js的文件，则尝试加载 .json 结尾的文件
  如果没有 .json 的文件，则尝试加载 .node 结尾的文件
  查找规则：index  ->  index.js   ->   index.json   ->  index.node
  ```

### 第三方模块的加载机制【了解】

1. 先在项目根目录中查找`node_modules`文件夹
2. 在`node_modules`文件夹下，查找模块相关的文件夹
3. 在对应的文件夹下，查找`package.json`的文件
4. 查找`package.json`文件中的`main`属性（指定了模块的入口文件）
5. 如果找到了`main`属性，同时，`main`属性指定的文件路径存在，那么尝试加载指定的文件模块
6. 加入没有`main`属性，或者`main`属性对应的文件不存在，或者没有`package.json`,那么会依次尝试加载`index.js`，`index.json`,`index.node`;
7. 如果没有`index`相关的文件，或者没有指定模块对应文件夹，或者，当前项目根目录中没有`node_modules`文件夹，则向上一层目录中查找`node_modules`，查找规则同上！
8. 最后，如果在项目所在磁盘的盘符根目录中，还找不到对应模块，则报错：`cannot find module ***`