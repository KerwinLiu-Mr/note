# 基础部分

## 技术起源题

- **XHTML** 与 **HTML** 有什么区别？

html:超文本标记语言 (Hyper Text Markup Language);

xhtml:可扩展超文本标记语言，是一种置标语言，表现方式与超文本标记语言（HTML）类似，不过语法上更加严格

xhtml语法特点：

1.所有的标记都必须要有一个相应的结束标记

2.所有标签的元素和属性的名字都必须使用小写 

3.所有的 XML 标记都必须合理嵌套

4.所有的属性必须用引号""括起来

5.给所有属性赋一个值=""

6.不要在注释内容中使“--”="""

7.图片必须有说明文字="" <="" code=""/>

- **Doctype**作用? 严格模式与混杂模式如何区分？它们有何意义？

<!DOCTYPE>声明叫做文件类型定义（DTD），声明的作用为了告诉浏览器该文件的类型。让浏览器解析器知道应该用哪个规范来解析文档。<!DOCTYPE>声明必须在 HTML 文档的第一行，这并不是一个 HTML 标签。

**严格模式** : 又称标准模式，是指浏览器按照 W3C 标准解析代码

**混杂模式：**又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码.

**如何区分：**浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。

1、如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。**（严格 DTD ——严格模式） **
2、包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。**（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式） **
3、DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。**（DTD不存在或者格式不正确——混杂模式）**
4、HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。**（ HTML5 没有严格和混杂之分)**

**意义：**严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。

- 介绍一下对浏览器内核的理解

主要分成两个部分：渲染引擎(Render Engine)和JS引擎。

**渲染引擎**：负责取得网页的内容(html,xml和图像等)，整理讯息(例如假如css)，以及计算网页的显示方式，然后输出到显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不同。所有网页浏览器、电子邮件客户端以及它需要编辑、显示网络内容的应用程序都需要内核。

**JS引擎**：解析和执行JavaScript来实现网页的动态效果

最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向与只指渲染引擎。

常见浏览器内核

IE--Trident

Firefox---Gecko

Safari----Webkit

Chrome--Blink

Opera(欧朋)--Blink

- 对WEB标准以及W3C的理解与认识

web标准简单来说可以分为结构、表现和行为。web标准一般是将该三部分独立分开，使其更具有模块化。但一般产生行为时，就会有结构或者表现的变化，也使这三者的界限并不那么清晰。

W3C对web标准提出了规范化的要求，也就是在实际编程中的一些代码规范：包含如下几点

1.对于结构要求：（标签规范可以提高搜索引擎对页面的抓取效率，对SEO很有帮助）

1）标签字母要小写

2）标签要闭合

3）标签不允许随意嵌套

2.对于css和js来说

1）尽量使用外链css样式表和js脚本。是结构、表现和行为分为三块，符合规范。同时提高页面渲染速度，提高用户的体验。

2）样式尽量少用行间样式表，使结构与表现分离，标签的id和class等属性命名要做到见文知义，标签越少，加载越快，用户体验提高，代码维护简单，便于改版

3）不需要变动页面内容，便可提供打印版本而不需要复制内容，提高网站易用性。

- **Iframe**的作用？
  iframe 是用来在网页中插入第三方页面，早期的页面使用 iframe 主要是用于导航栏这种很多页面都相同的部分，这样可以在切换页面的时候避免重复下载。

iframe 对于 SEO 不友好，iframe 的创建比一般的 DOM 元素慢了 1-2 个数量级，iframe 标签会阻塞页面的加载，如果页面的 onload 事件不能及时触发，会让用户觉网页加载很慢，用户体验不好。

替代方案一般就是ajax 动态填充内容。

## **Css2/3**

- **CSS3** 新特性有哪些**

1. 颜色：新增 RGBA，HSLA 模式

2. 文字阴影（text-shadow）

3. 边框： 圆角（border-radius） 边框阴影： box-shadow

4. 盒子模型：box-sizing

5. 背景：background-size 设置背景图片的尺寸 background-origin 设置背景图片

   的原点 background-clip 设置背景图片的裁切区域，以”，”分隔可以设置多背景，用于自适应布局

6. 渐变：linear-gradient、radial-gradient

7. 过渡：transition，可实现动画

8. 自定义动画

9. 在 CSS3 中唯一引入的伪元素是 ：selection

10. 媒体查询，多栏布局

11. 2D 转换：transform：translate(x，y) rotate(x，y) skew(x，y) scale(x，y)

- 描述一下CSS中的渐进增强，优雅降级之间的区别

渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。

优雅降级 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。

- 对BFC规范的理解有哪些？

给这些元素添加如下属性就可以触发BFC。

直译为"块级格式化上下文"。

-float属性不为none

-position为absolute或fixed

-display为inline-block, table-cell, table-caption, flex, inline-flex

-overflow不为visible

BFC布局规则特性：

1.在BFC中，盒子从顶端开始垂直地一个接一个地排列.

2.盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠

3.在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。

1. BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。
2. 计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。

它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。

BFC的主要用途

(1) 清除元素内部浮动

只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了。主要用到 计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。

(2) 解决外边距合并问题

外边距合并的问题：主要用到 盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠。

属于同一个BFC的两个相邻盒子的margin会发生重叠，那么我们创建不属于同一个BFC，就不会发生margin重叠了。

(3) 制作右侧自适应的盒子问题

主要用到 ：普通流体元素BFC后，为了和浮动元素不产生任何交集，顺着浮动边缘形成自己的封闭上下文。

BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。包括浮动，和外边距合并等等，因此，有了这个特性，我们布局的时候就不会出现意外情况了。

- **你遇到过的兼容问题有哪些？如何解决的？**

1、png24 位的图片在 iE6 浏览器上出现背景，解决方案是做成 PNG8.

2、浏览器默认的 margin 和 padding 不同。解决方案是加一个全局的{margin：0;padding：0;}来统一。

3、 IE 下,可以使用获取常规属性的方法来获取自定义属性,也可以使用 getAttribute()获取自定义属性;Firefox 下,只能使用 getAttribute()获取自定义属性，统一通过 getAttribute()获取自定义属性。

4、鼠标在当前页面的位置pageX和pageY有兼容性问题，从ie9以后才支持。

pageX = clientX + 滚动出去的距离。
pageY = clientY+ 滚动出去的距离。 

获得页面滚动出去的距离的浏览器兼容性，谷歌中document.body.scrollLeft获取页面滚动出的距离，在ie中

document.documentElement.scrollLeft。

5、Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示,可通过加入 CSS 属性 -webkit-text-size-adjust：none; 解决

- 如何清除浮动

1、父级盒子给高度，适合高度固定布局

2、结尾处加空 div 标签 clear：both。

3、给父级盒子添加双伪元素after、before

4、给父级盒子添加overflow: hidden,生成BFC特性。

- 适应不同终端的方案

1、流式布局，百分比布局。

2、 响应式布局，媒体查询、boostrap框架

超小屏幕（移动设备） 768px 以下

小屏设备 768px-992px

中等屏幕 992px-1200px

宽屏设备 1200px 以上

- 移动WEB和响应式有什么分别？
  - 移动WEB一般是在已有PC端网站，只需开发移动端，开发效率高、只适配移动设备，pad上体验较差。
  - 响应式一套页面适应pc和移动端，开发效率低。
- px em rem 取用选择依据

px 像素（Pixel）相对单位，在设备屏幕尺寸相同，PPI不同(像素密度)的设备上，当PPI 越大，像素的实际大小就会越小，当PPI越小，像素实际大小就越大。

em 是相对长度单位，相对于当前对象内文本的字体尺寸。默认是浏览器字体尺寸，它会继承父级元素的字体大小，因此不是一个固定的值。

rem 是 CSS3 新增的一个相对单位（root em，根 em），使用 rem 为元素设定字体大小时，仍然是相对大小，但相对的只是 HTML 根元素。

区别：IE 无法调整那些使用 px 作为单位的字体大小，而 em 和 rem 可以缩放，

rem 相对的只是 HTML 根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了 IE8 及更早版本外，所有浏览器均已支持 rem。

- 盒子水平居中方案

1、position:absolute + transform

2、flex+justify-content： center     + align-items：center

- src和href的区别

**href表示超文本引用**，用在**link**和**a**等元素上，**href是引用和页面关联**，是在当前元素和引用资源之间建立联系。

**src**表示引用资源，表示替换当前元素，用在**img**，**script**，**iframe**上，src是页面内容不可缺少的一部分。

**src**是source的缩写，是指向外部资源的位置，指向的内部会迁入到文档中当前标签所在的位置；在请求**src**资源时会将其指向的资源下载并应用到当前文档中，例如js脚本，img图片和frame等元素。

\<script **src**="js.js">\</script>当浏览器解析到这一句的时候**会暂停其他资源的下载和处理，直至将该资源加载，编译，执行完毕**，图片和框架等元素也是如此，类似于该元素所指向的资源嵌套如当前标签内，这也是为什么要把js放在底部而不是头部。

\<link **href**="common.css" rel="stylesheet"/>当浏览器解析到这一句的时候会识别该文档为css文件，**会下载并且不会停止对当前文档的处理**。

补充：link和@import的区别

两者都是外部引用CSS的方式，但是存在一定的区别：

区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。

区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。

区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。

区别4：link支持使用Javascript控制DOM去改变样式；而@import不支持。

- this的理解

在普通函数中的this创建的时候不确定，在调用的时候才确定。如果纯粹的函数调用指向window对象。

如果被构造函数所调用，this执行当前new 出来的那个对象。

如果是作为象的方法被调用，执行调用对象。	

我们还可以修改函数中this的执行：如call，apply，bind.

- post提交数据表单，数据包在路上有没有被加密

使用http：比如你在POST提交表单时， 数据按`HTTP`协议封装成`http`报文， 
计算机把该`http报文`直接交付给下层`tcp`协议，`tcp`协议通过三次握手建立与目的主机的通信， 把该数据包交付下层`IP协议`， `IP协议`把数据包封装成`IP数据包`从而交给下层`数据链路层`传输到目的主机。

此时，是没有明文传输，没有加密。

使用https:

当你使用`https`是， 数据在传输过程中是经过加密的， 若使用`https`， 则数据包在交付给`TCP`协议前， 会先把数据交给位于`http`和`tcp`中间的`ssl`， 数据包先经过`ssl`按特定加密， 在传输给下层协议

所以理论上说， https协议是安全的。

- 异常对象Error

Error.message 可以读取的错误消息

Error.name 错误的类型

Error.toString( ) 把 Error 对象转换成字符串

EvalError 在不正确使用 eval()时抛出

SyntaxError 抛出该错误用来通知语法错误

RangeError 在数字超出合法范围时抛出

ReferenceError 在读取不存在的变量时抛出

TypeError 当一个值的类型错误时，抛出该异常

URIError 由 URl 的编码和解码方法抛出

- Vue中如何动态的对异步组件进行加载
- Vue动态路由的实现
- 图形化工具
- Mui和boostrap
- 原生JS
- vue再了解了解。。

