###字体图标的标准用法

- 常用字体图标网站：http://www.fontawesome.com.cn/

- 用法： 下载文件

  将css、fonts引入到自己的项目里面

  将css通过link的形式引入进来

  复制对应的字体图标的代码标签

- 我们在使用字体图标时，需要引入需要的样式（基类），同时指定我们想要的字体图标（unicode编码）。
  我们需要添加想要的字体图标的unicode编码，同时为了可读性不能直接写在标签里面，而是利用伪元素增加可读性。
  如：一个字体图标笑脸的unicode的编码为 $#xe641,我们可以使用伪元素的content属性将编码插入。
  举例： .myFont{
    font-family: iconfont;

        }
        /*笑脸*/
        .smile::before{
            content: "\e641";
            color: red;
            font-size: 50px;
        }
  《span class="myFont smile"></span》
###多列布局
CSS3中新出现的多列布局(multi-column)是传统HTML网页中块状布局模式的有力扩充。这种新语法能够让WEB开发人员轻松的让文本呈现多列显示。我们知道，当一行文字太长时，读者读起来就比较费劲，有可能读错行或读串行；人们的视点从文本的一端移到另一端、然后换到下一行的行首，如果眼球移动浮动过大，他们的注意力就会减退，容易读不下去。所以，为了最大效率的使用大屏幕显示器，页面设计中需要限制文本的宽度，让文本按多列呈现，就像报纸上的新闻排版一样CSS3中新出现的多列布局(multi-column)是传统HTML网页中块状布局模式的有力扩充。这种新语法能够让WEB开发人员轻松的让文本呈现多列显示。我们知道，当一行文字太长时，读者读起来就比较费劲，有可能读错行或读串行；人们的视点从文本的一端移到另一端、然后换到下一行的行首，如果眼球移动浮动过大，他们的注意力就会减退，容易读不下去。所以，为了最大效率的使用大屏幕显示器，页面设计中需要限制文本的宽度，让文本按多列呈现，就像报纸上的新闻排版一样。
- 设置列数
   column-count: 3;
- 2.添加列间隙的样式  与边框样式的添加一样
   column-rule: 3px dashed red;
- 3.设置列间隙的大小
   column-gap: 50px;
- 设置列宽
   原则取大优先
1. 如果人为设置的宽度大，则取人为设置的值，但是需要填充整个屏幕，所以最终的宽度也可能大于设置的宽度--填满整个屏幕. 如果设置的宽度过大，为了保证填满整个屏幕可能会自动修改列数。
2. 如果人为设置宽度更小，则取默认计算的宽度。
   column-width: 500px;
- /设置跨列显示 参数为：1或all。
   column-span: all;
###伸缩布局（重点）
布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便。CSS3在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。

#### 如何设置伸缩盒子、主轴和侧轴

- 如何设置伸缩布局：设置父容器为伸缩盒子：会使每一个子元素自动变成伸缩项。

- 注意：当子元素的宽度和大于父容器宽度的时候，子元素会自动平均收缩。
  给父容器添加  **display: flex;**

- 开启伸缩布局后的效果，设为Flex布局以后，**子元素的float、clear和vertical-align属性将失效**，并且默认不换行，如果子元素的宽度超过了父元素的宽度，自动缩放

- 我们可以设置主轴的排列方向

  **flex-direction**：设置子元素的排列方向：就是主轴方向，默认主轴方向是row(水平方向)。
  row:水平排列方向，从左到右，默认值。
  row-reverse:水平排列方向，从右到左
  column:垂直排列方向，从上到下
  column-reverse：垂直排列方向，从下到上

- 还可以设置子元素在主轴方向上的排列样式 

  **justify- content**：
  flex-start: 让子元素从父容器的起始位置开始排列，默认值。
  flex-end：让子元素从父容器的结束位置开始排列 
  center：让子元素从父容器的中间位置开始排列 
  space-between: 左右对齐父容器的开始和结束，中间平均分布，产生相同的间距
  space-around：将多余的空间平均的分布在每一个子元素的两边 margin: 0 auto;
  造成的结果：中间盒子的间距是两边盒子的两倍。

- **flex-flow**:是flex-wrap和flex-direction的综合。

- flex-wrap:控制子元素是否换行显示，默认不换行
  nowrap:不换行--则收缩。
  wrap:换行
  wrap-reverse:翻转，原来是从上到下，翻转后就是从下到上来排列。

- flex-flow的综合写法：没有顺序要求
  flex-flow: row wrap;

- 与主轴相对的还有一个侧轴，与主轴垂直。如果主轴改变，侧轴也会改变不过还是与主轴保持垂直。

  **align-items**:设置子元素(伸缩项)在侧轴方向上的对齐方式。

  center:设置在侧轴方向上居中对齐
  flex-start:设置在侧轴方向上顶对齐	
  flex-end设置在侧轴方向上底对齐
  stretch:拉伸：让子元素在侧轴方向上进行拉伸，填充满整个侧轴方向>> 默认值，如果**有宽度的话就不会填满**
  baseline:文本基线
  **注意**：这是在父容器上给所有的子元素设置侧轴对齐方式。
  我们可以给某个子元素单独设置侧轴对齐方式

  **align-content**: 设置子元素在侧轴方向上的间距

  ​	space-between: 左右对齐父容器的开始和结束，中间平均分布，产生相同的间距
  ​	space-around：将多余的空间平均的分布在每一个子元素的两边 margin: 0 auto;
  ​	造成的结果：中间盒子的间距是两边盒子的两倍。

  **align-self**： 设置单个元素在侧轴方向上的对齐方式。

  参数与align-items相同。
####flex属性：
flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。
- flex-grow：注意是对子元素进行设置，需要写在子元素的样式里面。
  flow-grow:可以来扩展子元素的宽度：**设置当前元素应该占据剩余空间的比例值**。
  比例值计算 ：当前元素的flex-grow/所有兄弟元素（包含自身）的flex-grow的和。
  flex-grow的默认是0:说明子元素并不会去占据剩余的空间。
  flex-grow: 1;
- flex-shrink：**前提条件**：当父容器放不下子元素时，子元素会进行收缩，**flex-shrink可以定义子元素的收缩比例**。
  flex-shrink:定义收缩比例，通过设置的值来计算收缩空间。
  比例值计算 ：当前元素的flex-shrink/所有兄弟元素的flex-shrink的和。
  默认值为1。
  flex-shrink：2;
- flex:[number];这个语法指定了一个数字，代表了这个伸缩项目该占用的剩余空间比例.
  flex:auto; 属性值被设为auto的伸缩项目，会根据主轴自动伸缩以占用所有剩余空间.
  举例：
  **注意子元素不设置width,那么剩余空间就是父容器的宽度，使用flex来瓜分这些空间**。
  ```html
        .left{
        flex: 1;
        height: 500px;
        background-color: red;
    }
    .right{
         flex: 4; 
        height: 500px;
        background-color: blue;  }
  <div class="box">
    <div class="left"></div>
    <div class="right"></div>
  </div>
  ```

###定位的常见做法
如果定位是以浏览器的左上角或者右上角来做的话，当浏览器的大小发生变化时，由于设置了定位属性，可能导致内容的重叠。
所以我们一般把left 和 top 设置都设为50%，这样就相当于浏览器的中心，然后再设置偏移。不管浏览器的大小怎么变化，中心位置是不变的。 
###问题
伸缩盒子布局什么场合使用？
  ​

  ​

  ​















